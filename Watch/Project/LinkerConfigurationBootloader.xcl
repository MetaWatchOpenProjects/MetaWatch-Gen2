// ************************************************
//
// XLINK configuration file for MSP430F5438A
//
// Copyright 1996-2010 IAR Systems AB
//
// $Revision: 1.1 $
//
// ************************************************

// ---------------------------------------------------------
// Description
//

//
// Usage:
//
//   xlink [file file ...] -f lnk430f5438a.xcl
//
// -----------------------------------------------
// Device summary
//

//
// Core:                           MSP430X
//
// Interrupt vectors:              64
//
// Peripheral units:                   0-001FF
//
// Information memory (FLASH):     01800-019FF
//
// Read/write memory (RAM):        01C00-05BFF
//
// Read-only memory (FLASH):       05C00-0FFFF
//                                 10000-45BFF
//


// -----------------------------------------------
// Segments
//

// -------------------------------------
// Data read/write segments (RAM)
//

//
// The following segments are available for both
// the DATA16 and DATA20 segment groups.
//
// segment         Usage
// -------         --------------------------
// DATA<nn>_Z      Data initialized to zero
// DATA<nn>_I      Data initialized by copying from DATA<nn>_ID
// DATA<nn>_N      Data defined using __no_init
// DATA<nn>_HEAP   The heap used by 'malloc' and 'free'
//
// segment         Usage
// -------         --------------------------
// CSTACK          Runtime stack
//


// -------------------------------------
// Program and data read-only segments (FLASH)
//

//
// The following segments are available for both
// the DATA16 and DATA20 segment groups.
//
// segment         Usage
// -------         --------------------------
// DATA<nn>_C      Constant data, including string literals
// DATA<nn>_ID     initializers for DATA<nn>_I
//
// segment         Usage
// -------         --------------------------
// INFO            Information memory
// INFOA           Information memory, bank A
// INFOB           Information memory, bank B
// INFOC           Information memory, bank C
// INFOD           Information memory, bank D
// CSTART          Program startup code
// CODE            Program code
// ISR_CODE        Program code for interrupt service routines
// DIFUNCT         Dynamic initialization vector used by C++
// CHECKSUM        Checksum byte(s) generated by the -J option
// INTVEC          Interrupt vectors
// RESET           The reset vector
//
// Notes:
//
// * The segments CSTART, ISR_CODE, and DIFUNCT, as well as the segments in
//   the DATA16 segment group must be placed in in the range 0000-FFFD.
//
// * The INFOx and INFO segments overlap, this allows data either to be
//   placed in a specific bank or anywhere in the info memory.
//
// * The INTVEC and RESET segments overlap. This allows an application to
//   either use the reset vector provided by the runtime library, or
//   provide a reset function by defining an interrupt function associated
//   with the reset vector.
//


// ---------------------------------------------------------
// Configuration
//

// CPU30 Errata
-D?CPU30_OFFSET=2

// -----------------------------------------------
// Bootloader forward declarations
//

//-D_RAM_BEG=1C00 Save 16 bytes for values shared between bootloader and app
-D_RAM_BEG=1C10
-D_RAM_END=5B7F
-D_INTVEC_SIZE=0x80
-D_INTRAM_BEG=(_RAM_END+1)
-D_INTRAM_END=(_RAM_END+_INTVEC_SIZE)
// -----------------------------------------------
// Stack and heap sizes
//

// Uncomment for command line use
//-D_STACK_SIZE=80
//-D_DATA16_HEAP_SIZE=80
//-D_DATA20_HEAP_SIZE=80


// -----------------------------------------------
// Define cpu
//

-cmsp430


// -----------------------------------------------
// Support for placing functions in read/write memory
//

-QCODE_I=CODE_ID


// ---------------------------------------------------------
// Placement directives
//

// -----------------------------------------------
// Read/write memory
//

// share ram for bootloader and main application
-Z@(DATA)DATA16_I,DATA16_Z,DATA16_N,DATA16_HEAP+_DATA16_HEAP_SIZE=_RAM_BEG-_RAM_END
-Z@(DATA)BL_DATA16_I,BL_DATA16_Z,BL_DATA16_N=_RAM_BEG-_RAM_END
// ignore overlap warning
-we24=i


-Z(DATA)CODE_I
-Z(DATA)DATA20_I,DATA20_Z,DATA20_N,DATA20_HEAP+_DATA20_HEAP_SIZE
-Z(DATA)CSTACK+_STACK_SIZE#

// -------------------------------------
// Information memory
//

-Z(CONST)INFO=1800-19FF
-Z(CONST)INFOA=1980-19FF
-Z(CONST)INFOB=1900-197F
-Z(CONST)INFOC=1880-18FF
-Z(CONST)INFOD=1800-187F

// OSAL NV
-D_NV_BEGIN=0x0F200
-D_NV_END=0x0F9FF
-Z(CODE)NV_ADDRESS_SPACE=_NV_BEGIN-_NV_END

// Watch Faces Template memory
-D_TEMPLATE_FLASH_MEM_BEGIN=0x459ff //0x44400
-D_TEMPLATE_FLASH_MEM_END=0x45bff
-Z(CODE)TEMPLATE_FLASH_HIGH_MEM=_TEMPLATE_FLASH_MEM_BEGIN-_TEMPLATE_FLASH_MEM_END

// ---------------------------
// Bootloader
//
-D_LO_FLASH_BEG=0x5C00
-D_LO_FLASH_END=0xFDFF

-D_BOOT_SEG_SIZE=0x1400

-DBOOT_SEG_BEG=_LO_FLASH_BEG
-DBOOT_SEG_END=(BOOT_SEG_BEG+(_BOOT_SEG_SIZE-1))
-DCHECKSUM_SEG_BEG=(BOOT_SEG_END+1)
-DCHECKSUM_SEG_END=(CHECKSUM_SEG_BEG+1)
-DSHADOW_CHECKSUM_SEG_BEG=(CHECKSUM_SEG_END+1)
-DSHADOW_CHECKSUM_SEG_END=(SHADOW_CHECKSUM_SEG_BEG+1)
-DIMAGE_DATA_SEG_BEG=(SHADOW_CHECKSUM_SEG_END+1)
-DIMAGE_DATA_SEG_END=(IMAGE_DATA_SEG_BEG+0x1B)
-DAPPL_SEG_BEG=(IMAGE_DATA_SEG_END+1)

// normally application segment end is 0x45BFF but we reserve space for
// the watch face templates
-DAPPL_SEG_END=(_TEMPLATE_FLASH_MEM_BEGIN-1)

-Z(CODE)BL_CODE=BOOT_SEG_BEG-BOOT_SEG_END
-Z(CONST)BL_DATA16_C=BOOT_SEG_BEG-BOOT_SEG_END
-Z(CODE)BL_ISR_CODE=BOOT_SEG_BEG-BOOT_SEG_END

// ---------------------------
// Constant data
//
-Z(CONST)CHECKSUM=CHECKSUM_SEG_BEG-CHECKSUM_SEG_END
-Z(CONST)SHADOW_CHECKSUM=SHADOW_CHECKSUM_SEG_BEG-SHADOW_CHECKSUM_SEG_END
-Z(CONST)IMAGE_DATA=IMAGE_DATA_SEG_BEG-IMAGE_DATA_SEG_END

// ---------------------------
// Code
//

-Z(CODE)CSTART,ISR_CODE=APPL_SEG_BEG-0xF1FF,0xFA00-0xFDFF

// ---------------------------
// Constant data
//

-Z(CONST)ALTVECT_ID,DATA16_C,DATA16_ID,DIFUNCT=APPL_SEG_BEG-0xF1FF,0xFA00-0xFDFF

// ---------------------------
// Code
//

-P(CODE)CODE=APPL_SEG_BEG-0xF1FF,0xFA00-0xFDFF,0x10000-APPL_SEG_END
-Z(CODE)CODE_ID

// ---------------------------
// Constant data
//

-Z(CONST)DATA20_C,DATA20_ID,_IMAGE_END=APPL_SEG_BEG-0xF1FF,0xFA00-0xFDFF,0x10000-0x45BFF

// -------------------------------------
// Interrupt vectors
//
-Z(CODE)ALTVECT_I#0x5B80-0x5BFF     // force to be aligned to downward from highest addr
-Z(CODE)INTVEC=FF80-FFFF
-Z(CODE)RESET=FFFE-FFFF

//
//  IMPORTANT!
//  The ending address of the code image must be set to the address of the _IMAGE_END
//  segment as shown in the .map file.  This allows the calculation of the correct CRC
//  to be performed by the linker.
//
//  This is also a 2 step process and is performed as follows:
//  1. Set the end address of the third CRC segment to 0x45BFF.  This is the last value
//     specified in the -J2 line shown below. Build and link the code.
//  2. Get the address of _IMAGE_END as shown in the .map file and replace the end
//     address of the third segment with this value.  Build and link the code.
//
//  This is somewhat cumbersome but there is no way with XLINK to dynamically set
//  the addresses such that all of the first and second segments along with third segment
//  and its dynamic end address can be set using linker commands.
//
// -------------------------------------
// Checksum
//

// STEP 1
-J2,crc16,,,,2=APPL_SEG_BEG-0xF1FF,0xFA00-0xFDFF,0x10000-0x42BCE